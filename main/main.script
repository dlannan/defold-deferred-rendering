
function init(self)
	msg.post("@render:", "use_camera_projection")
	msg.post("sceneCam", "acquire_camera_focus")
	
	-- rotate the cube
	go.animate("/main", "euler.z", go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_INOUTQUAD, 6)
	go.animate("/main", "euler.x", go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_INOUTQUAD, 9)
	go.animate("/main", "euler.y", go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_INOUTQUAD, 12)

	-- tint the cube and the sphere
	model.set_constant("/main#cube", "tint", vmath.vector4(1,1,0,1))
	model.set_constant("/main#sphere", "tint", vmath.vector4(1,0,0,1))
	
	-- position directional light
	self.light = vmath.vector4(0, 0, go.get_position().z + 1, 0)

	msg.post("@render:", "add_pass", { index=0, name="albedo", outtex=1 })
	msg.post("@render:", "add_pass", { index=1, name="specular", outtex=1 })
	msg.post("@render:", "add_combine", { index=0, name="fullscreen", tex1=0, tex2=1, outtex=1 })
	msg.post("@render:", "add_combine", { index=1, name="fullscreen-blend", tex1=-1, tex2=1, outtex=nil })


	local deferredCam1 = vmath.matrix4_translation(vmath.vector3(-20, 0, -5))
	local deferredCam2 = vmath.matrix4_translation(vmath.vector3(-20, 0, -10))
	local deferredView1 = { matrix = deferredCam1, vp = vmath.vector4(660, 100, 200.0, 160.0) }
	local deferredView2 = { matrix = deferredCam2, vp = vmath.vector4(0, 100, 640.0, 400.0) }
	msg.post("@render:", "set_view", { index=0, combine=1, view=deferredView1 } )
	msg.post("@render:", "set_view", { index=1, combine=1, view=deferredView2 } )	
end

function on_input(self, action_id, action)
	-- move directional light based on input
	self.light.x = 2 * ((action.x - 480) / 480)
	self.light.y = 2 * ((action.y - 320) / 320)
-- 	model.set_constant("#cube", "light", self.light)
-- 	model.set_constant("#quad", "light", self.light)
-- 	model.set_constant("#sphere", "light", self.light)
end

function update(self)
	-- msg.post("@render:", "use_camera_projection")
	-- msg.post("sceneCam", "acquire_camera_focus")
end